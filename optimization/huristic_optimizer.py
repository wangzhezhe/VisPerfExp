import numpy
from random import randint
from time import sleep
import time
import matplotlib.pyplot as plt
import shutil
import os
import sys
# the source code come from
# 
num_rank=8
#function_inputs = range(0,num_rank,1) # Function inputs. from 0 to n-1
# we do not need function input here, this is just a synthetic value
function_inputs = 0
desired_output = 0 # Function output.

# https://stackoverflow.com/questions/8713620/appending-to-one-list-in-a-list-of-lists-appends-to-all-other-lists-too
# be carefule of this, modify one, modify all
# generate assignment config from solution plan, and then execute the function, and get associated execution times
def get_exec_time(solution_plan):
    # print("function_inputs:", function_inputs)
    # run the particle advection to get exec time
    # psudu code, sleep random time
    start = time.time()
    # sleep(randint(1,3)/1000)
    # generate a assign_options.config according to input
    assignment_list=[[] for _ in range(len(solution_plan))]
    for index, v in enumerate(solution_plan):
        #print(index, v)
        #the value generated by generic algorithm might not be integer
        if (int(v)>(num_rank-1)):
            assignment_list[num_rank-1].append(index)
        else:
            assignment_list[int(v)].append(index)
    print("assignment_list is", assignment_list)

    # write out plan
    occupied_process=0
    f = open("assign_options.config",'w')
    for index, blocks in enumerate(assignment_list):
        #print(index, blocks)
        if len(blocks)==0:
            f.write("\n")
            continue
        
        occupied_process=occupied_process+1
        for i, bid in enumerate(blocks):
            if i==0:
                f.write(str(bid))
            else:
                f.write(" "+str(bid))
        f.write("\n")
    f.close() 
    
    # call the particle advection based on plan
    os.system('/bin/bash runtask.sh')
    
    end = time.time()
    exec_time = end-start
    return exec_time,occupied_process

def fitness_func(ga_instance, solution, solution_idx):
    print("solution",solution)
    #exec_time, occupied_process = get_exec_time(solution)

    #synthetic option
    exec_time = 1+randint(1,3)
    occupied_process=2+randint(1,3)/1000
    sleep(randint(1,3)/1000)
    # count occupied process
    core_time=exec_time*occupied_process
    print("exec_time",exec_time,"occupied_process",occupied_process)
    fitness = 1.0 / numpy.abs(core_time - desired_output + 0.001)
    return fitness

def parse_log_get_adv_percentage(dirPath):
# parse log and get advection percentage for each rank
    filter_time=0
    # get filter time, use the rank0's filter time as the total one
    file_name = dirPath+"/timetrace.0.out"
    fo=open(file_name, "r")
    filter_end="FilterEnd_0"
    for line in fo:
        line_strip=line.strip()
        split_str= line_strip.split(" ")    
        if filter_end in line_strip:
            filter_end_time = float(split_str[1])
            filter_time = filter_end_time
    fo.close()
    print("filter_time",filter_time)    # get filter execution time, use rank 0's log
    
    for rank in range(0,num_rank,1):
        # open timetrace file
        file_name = dirPath+"/timetrace."+str(rank)+".out"
        print(file_name)
        fo=open(file_name, "r")
        work_start="ParticleAdvectStart_0"
        work_end="ParticleAdvectEnd_0"
        work_start_time=0
        acc_work_time=0
        fo=open(file_name, "r")
        for line in fo:
            line_strip=line.strip()
            split_str= line_strip.split(" ")
            if work_start in line_strip:
                work_start_time=float(split_str[1])
            if work_end in line_strip:
                work_end_tim = float(split_str[1])
                acc_work_time = acc_work_time+(work_end_tim-work_start_time)
        fo.close()
        print("acc work time ratio for rank", rank, acc_work_time/filter_time)

# parse the log of previous output and get new execution plan
# def parse_log_get_new_plan():
# compute the adv percentage for each rank

# sort the percentage from small to large

# do assignment, long job first, set the upper limitation

# if the percentage exceeds specific limiation, than move to a new process
# this will determine how many process will be used, using the greedy strategy here

if __name__ == "__main__":
    if len(sys.argv)!=2:
        print("<binary> <runDirPath>")
        exit()
    dirPath=sys.argv[1]
    parse_log_get_adv_percentage(dirPath)